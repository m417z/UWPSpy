// WARNING: Please don't edit this file. It was generated by C++/WinRT v2.0.220110.5

#pragma once
#ifndef WINRT_Microsoft_Windows_ApplicationModel_Resources_H
#define WINRT_Microsoft_Windows_ApplicationModel_Resources_H
#include "winrt/base.h"
static_assert(winrt::check_version(CPPWINRT_VERSION, "2.0.220110.5"), "Mismatched C++/WinRT headers.");
#define CPPWINRT_VERSION "2.0.220110.5"
#include "winrt/impl/Windows.Foundation.2.h"
#include "winrt/impl/Windows.Foundation.Collections.2.h"
#include "winrt/impl/Microsoft.Windows.ApplicationModel.Resources.2.h"
namespace winrt::impl
{
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::Contrast() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_Contrast(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::Custom() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_Custom(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::DeviceFamily() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_DeviceFamily(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::HomeRegion() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_HomeRegion(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::Language() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_Language(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::LayoutDirection() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_LayoutDirection(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::Scale() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_Scale(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::TargetSize() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_TargetSize(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IKnownResourceQualifierNameStatics<D>::Theme() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics)->get_Theme(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<D>::ValueAsString() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate)->get_ValueAsString(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(com_array<uint8_t>) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<D>::ValueAsBytes() const
    {
        uint32_t value_impl_size{};
        uint8_t* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate)->get_ValueAsBytes(&value_impl_size, &value));
        return com_array<uint8_t>{ value, value_impl_size, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<D>::Kind() const
    {
        winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate)->get_Kind(reinterpret_cast<int32_t*>(&value)));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidate<D>::QualifierValues() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate)->get_QualifierValues(&value));
        return winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidateFactory<D>::CreateInstance(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind const& kind, param::hstring const& data) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidateFactory)->CreateInstance(static_cast<int32_t>(kind), *(void**)(&data), &value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceCandidateFactory<D>::CreateInstance2(array_view<uint8_t const> data) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidateFactory)->CreateInstance2(data.size(), get_abi(data), &value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IMap<hstring, hstring>) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceContext<D>::QualifierValues() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext)->get_QualifierValues(&value));
        return winrt::Windows::Foundation::Collections::IMap<hstring, hstring>{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoader<D>::GetString(param::hstring const& resourceId) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader)->GetString(*(void**)(&resourceId), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoader<D>::GetStringForUri(winrt::Windows::Foundation::Uri const& resourceUri) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader)->GetStringForUri(*(void**)(&resourceUri), &result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoaderFactory<D>::CreateInstance(param::hstring const& fileName) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderFactory)->CreateInstance(*(void**)(&fileName), &value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoaderFactory<D>::CreateInstance2(param::hstring const& fileName, param::hstring const& resourceMap) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderFactory)->CreateInstance2(*(void**)(&fileName), *(void**)(&resourceMap), &value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceLoaderStatics<D>::GetDefaultResourceFilePath() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderStatics)->GetDefaultResourceFilePath(&result));
        return hstring{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::MainResourceMap() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager)->get_MainResourceMap(&value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::CreateResourceContext() const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager)->CreateResourceContext(&result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::event_token) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::ResourceNotFound(winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceNotFoundEventArgs> const& handler) const
    {
        winrt::event_token token{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager)->add_ResourceNotFound(*(void**)(&handler), put_abi(token)));
        return token;
    }
    template <typename D> typename consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::ResourceNotFound_revoker consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::ResourceNotFound(auto_revoke_t, winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceNotFoundEventArgs> const& handler) const
    {
        return impl::make_event_revoker<D, ResourceNotFound_revoker>(this, ResourceNotFound(handler));
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManager<D>::ResourceNotFound(winrt::event_token const& token) const noexcept
    {
        WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager)->remove_ResourceNotFound(impl::bind_in(token));
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceManagerFactory<D>::CreateInstance(param::hstring const& fileName) const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManagerFactory)->CreateInstance(*(void**)(&fileName), &value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(uint32_t) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::ResourceCount() const
    {
        uint32_t value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->get_ResourceCount(&value));
        return value;
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::GetSubtree(param::hstring const& reference) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->GetSubtree(*(void**)(&reference), &result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::TryGetSubtree(param::hstring const& reference) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->TryGetSubtree(*(void**)(&reference), &result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::GetValue(param::hstring const& resource) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->GetValue(*(void**)(&resource), &result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::GetValue(param::hstring const& resource, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext const& context) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->GetValueWithContext(*(void**)(&resource), *(void**)(&context), &result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::GetValueByIndex(uint32_t index) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->GetValueByIndex(index, &result));
        return winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::GetValueByIndex(uint32_t index, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext const& context) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->GetValueByIndexWithContext(index, *(void**)(&context), &result));
        return winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::TryGetValue(param::hstring const& resource) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->TryGetValue(*(void**)(&resource), &result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceMap<D>::TryGetValue(param::hstring const& resource, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext const& context) const
    {
        void* result{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap)->TryGetValueWithContext(*(void**)(&resource), *(void**)(&context), &result));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate{ result, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceNotFoundEventArgs<D>::Context() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceNotFoundEventArgs)->get_Context(&value));
        return winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(hstring) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceNotFoundEventArgs<D>::Name() const
    {
        void* value{};
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceNotFoundEventArgs)->get_Name(&value));
        return hstring{ value, take_ownership_from_abi };
    }
    template <typename D> WINRT_IMPL_AUTO(void) consume_Microsoft_Windows_ApplicationModel_Resources_IResourceNotFoundEventArgs<D>::SetResolvedCandidate(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate const& candidate) const
    {
        check_hresult(WINRT_IMPL_SHIM(winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceNotFoundEventArgs)->SetResolvedCandidate(*(void**)(&candidate)));
    }
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics>
    {
        int32_t __stdcall get_Contrast(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Contrast());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Custom(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Custom());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_DeviceFamily(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().DeviceFamily());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_HomeRegion(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().HomeRegion());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Language(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Language());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_LayoutDirection(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().LayoutDirection());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Scale(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Scale());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_TargetSize(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().TargetSize());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Theme(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Theme());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate>
    {
        int32_t __stdcall get_ValueAsString(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().ValueAsString());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_ValueAsBytes(uint32_t* __valueSize, uint8_t** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            std::tie(*__valueSize, *value) = detach_abi(this->shim().ValueAsBytes());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Kind(int32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind>(this->shim().Kind());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_QualifierValues(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMapView<hstring, hstring>>(this->shim().QualifierValues());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidateFactory> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidateFactory>
    {
        int32_t __stdcall CreateInstance(int32_t kind, void* data, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>(this->shim().CreateInstance(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind const*>(&kind), *reinterpret_cast<hstring const*>(&data)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance2(uint32_t __dataSize, uint8_t* data, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>(this->shim().CreateInstance2(array_view<uint8_t const>(reinterpret_cast<uint8_t const *>(data), reinterpret_cast<uint8_t const *>(data) + __dataSize)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext>
    {
        int32_t __stdcall get_QualifierValues(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Windows::Foundation::Collections::IMap<hstring, hstring>>(this->shim().QualifierValues());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext2> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext2>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader>
    {
        int32_t __stdcall GetString(void* resourceId, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetString(*reinterpret_cast<hstring const*>(&resourceId)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetStringForUri(void* resourceUri, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetStringForUri(*reinterpret_cast<winrt::Windows::Foundation::Uri const*>(&resourceUri)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderFactory> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderFactory>
    {
        int32_t __stdcall CreateInstance(void* fileName, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&fileName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateInstance2(void* fileName, void* resourceMap, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader>(this->shim().CreateInstance2(*reinterpret_cast<hstring const*>(&fileName), *reinterpret_cast<hstring const*>(&resourceMap)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderStatics> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderStatics>
    {
        int32_t __stdcall GetDefaultResourceFilePath(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<hstring>(this->shim().GetDefaultResourceFilePath());
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager>
    {
        int32_t __stdcall get_MainResourceMap(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>(this->shim().MainResourceMap());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall CreateResourceContext(void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext>(this->shim().CreateResourceContext());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall add_ResourceNotFound(void* handler, winrt::event_token* token) noexcept final try
        {
            zero_abi<winrt::event_token>(token);
            typename D::abi_guard guard(this->shim());
            *token = detach_from<winrt::event_token>(this->shim().ResourceNotFound(*reinterpret_cast<winrt::Windows::Foundation::TypedEventHandler<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceNotFoundEventArgs> const*>(&handler)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall remove_ResourceNotFound(winrt::event_token token) noexcept final
        {
            typename D::abi_guard guard(this->shim());
            this->shim().ResourceNotFound(*reinterpret_cast<winrt::event_token const*>(&token));
            return 0;
        }
    };
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager2> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager2>
    {
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManagerFactory> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManagerFactory>
    {
        int32_t __stdcall CreateInstance(void* fileName, void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager>(this->shim().CreateInstance(*reinterpret_cast<hstring const*>(&fileName)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap>
    {
        int32_t __stdcall get_ResourceCount(uint32_t* value) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            *value = detach_from<uint32_t>(this->shim().ResourceCount());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetSubtree(void* reference, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>(this->shim().GetSubtree(*reinterpret_cast<hstring const*>(&reference)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryGetSubtree(void* reference, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap>(this->shim().TryGetSubtree(*reinterpret_cast<hstring const*>(&reference)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetValue(void* resource, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>(this->shim().GetValue(*reinterpret_cast<hstring const*>(&resource)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetValueWithContext(void* resource, void* context, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>(this->shim().GetValue(*reinterpret_cast<hstring const*>(&resource), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext const*>(&context)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetValueByIndex(uint32_t index, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>>(this->shim().GetValueByIndex(index));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall GetValueByIndexWithContext(uint32_t index, void* context, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Windows::Foundation::Collections::IKeyValuePair<hstring, winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>>(this->shim().GetValueByIndex(index, *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext const*>(&context)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryGetValue(void* resource, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>(this->shim().TryGetValue(*reinterpret_cast<hstring const*>(&resource)));
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall TryGetValueWithContext(void* resource, void* context, void** result) noexcept final try
        {
            clear_abi(result);
            typename D::abi_guard guard(this->shim());
            *result = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate>(this->shim().TryGetValue(*reinterpret_cast<hstring const*>(&resource), *reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext const*>(&context)));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
#ifndef WINRT_LEAN_AND_MEAN
    template <typename D>
    struct produce<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceNotFoundEventArgs> : produce_base<D, winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceNotFoundEventArgs>
    {
        int32_t __stdcall get_Context(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext>(this->shim().Context());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall get_Name(void** value) noexcept final try
        {
            clear_abi(value);
            typename D::abi_guard guard(this->shim());
            *value = detach_from<hstring>(this->shim().Name());
            return 0;
        }
        catch (...) { return to_hresult(); }
        int32_t __stdcall SetResolvedCandidate(void* candidate) noexcept final try
        {
            typename D::abi_guard guard(this->shim());
            this->shim().SetResolvedCandidate(*reinterpret_cast<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate const*>(&candidate));
            return 0;
        }
        catch (...) { return to_hresult(); }
    };
#endif
}
WINRT_EXPORT namespace winrt::Microsoft::Windows::ApplicationModel::Resources
{
    inline auto KnownResourceQualifierName::Contrast()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.Contrast(); });
    }
    inline auto KnownResourceQualifierName::Custom()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.Custom(); });
    }
    inline auto KnownResourceQualifierName::DeviceFamily()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.DeviceFamily(); });
    }
    inline auto KnownResourceQualifierName::HomeRegion()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.HomeRegion(); });
    }
    inline auto KnownResourceQualifierName::Language()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.Language(); });
    }
    inline auto KnownResourceQualifierName::LayoutDirection()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.LayoutDirection(); });
    }
    inline auto KnownResourceQualifierName::Scale()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.Scale(); });
    }
    inline auto KnownResourceQualifierName::TargetSize()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.TargetSize(); });
    }
    inline auto KnownResourceQualifierName::Theme()
    {
        return impl::call_factory_cast<hstring(*)(IKnownResourceQualifierNameStatics const&), KnownResourceQualifierName, IKnownResourceQualifierNameStatics>([](IKnownResourceQualifierNameStatics const& f) { return f.Theme(); });
    }
    inline ResourceCandidate::ResourceCandidate(winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidateKind const& kind, param::hstring const& data) :
        ResourceCandidate(impl::call_factory<ResourceCandidate, IResourceCandidateFactory>([&](IResourceCandidateFactory const& f) { return f.CreateInstance(kind, data); }))
    {
    }
    inline ResourceCandidate::ResourceCandidate(array_view<uint8_t const> data) :
        ResourceCandidate(impl::call_factory<ResourceCandidate, IResourceCandidateFactory>([&](IResourceCandidateFactory const& f) { return f.CreateInstance2(data); }))
    {
    }
    inline ResourceLoader::ResourceLoader() :
        ResourceLoader(impl::call_factory_cast<ResourceLoader(*)(winrt::Windows::Foundation::IActivationFactory const&), ResourceLoader>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ResourceLoader>(); }))
    {
    }
    inline ResourceLoader::ResourceLoader(param::hstring const& fileName) :
        ResourceLoader(impl::call_factory<ResourceLoader, IResourceLoaderFactory>([&](IResourceLoaderFactory const& f) { return f.CreateInstance(fileName); }))
    {
    }
    inline ResourceLoader::ResourceLoader(param::hstring const& fileName, param::hstring const& resourceMap) :
        ResourceLoader(impl::call_factory<ResourceLoader, IResourceLoaderFactory>([&](IResourceLoaderFactory const& f) { return f.CreateInstance2(fileName, resourceMap); }))
    {
    }
    inline auto ResourceLoader::GetDefaultResourceFilePath()
    {
        return impl::call_factory_cast<hstring(*)(IResourceLoaderStatics const&), ResourceLoader, IResourceLoaderStatics>([](IResourceLoaderStatics const& f) { return f.GetDefaultResourceFilePath(); });
    }
    inline ResourceManager::ResourceManager() :
        ResourceManager(impl::call_factory_cast<ResourceManager(*)(winrt::Windows::Foundation::IActivationFactory const&), ResourceManager>([](winrt::Windows::Foundation::IActivationFactory const& f) { return f.template ActivateInstance<ResourceManager>(); }))
    {
    }
    inline ResourceManager::ResourceManager(param::hstring const& fileName) :
        ResourceManager(impl::call_factory<ResourceManager, IResourceManagerFactory>([&](IResourceManagerFactory const& f) { return f.CreateInstance(fileName); }))
    {
    }
}
namespace std
{
#ifndef WINRT_LEAN_AND_MEAN
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IKnownResourceQualifierNameStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidate> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceCandidateFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceContext2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoader> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceLoaderStatics> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManager2> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceManagerFactory> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceMap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::IResourceNotFoundEventArgs> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::KnownResourceQualifierName> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceCandidate> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceContext> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceLoader> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceManager> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceMap> : winrt::impl::hash_base {};
    template<> struct hash<winrt::Microsoft::Windows::ApplicationModel::Resources::ResourceNotFoundEventArgs> : winrt::impl::hash_base {};
#endif
#ifdef __cpp_lib_format
#endif
}
#endif
